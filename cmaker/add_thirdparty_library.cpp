#include "functions.h"

extern po::options_description adder_library;
extern po::variables_map vm;

static std::string name = "undefined";
static fs::path inc_path;
static fs::path lib_path;
static std::string inc_names = "";
static fs::path inc_hints;

static void WriteCMakeFindModule();

void AddThirdpartyLibrary()
{
    if (!vm.count("name"))
    {
        LOGERR("missing library name for creating project!");
    }
    name = vm["name"].as<std::string>();

    if (!vm.count("inc"))
    {
        LOGWARN("header path is required");
        PrintUsageAndQuit(adder_library);
    }
    if (!vm.count("path"))
    {
        LOGWARN("library path is required\n");
        PrintUsageAndQuit(adder_library);
    }

    inc_path = fs::canonical(vm["inc"].as<std::string>());

    fs::path header_file = inc_path.filename();
    if (header_file.empty())
    {
        LOGERR("include hint: {} does not have header file", inc_path.string());
    }
    inc_names = header_file.string();

    inc_hints = inc_path.parent_path();
    LOGINFO("given header path: {}", inc_hints.string());

    if (!fs::exists(inc_path) || !fs::is_regular_file(inc_path))
    {
        LOGWARN("header file {{}} does not exist!", header_file.string());
    }

    if (!fs::exists(inc_hints) || !fs::is_directory(inc_hints))
    {
        LOGWARN("header include dir {{}} does not exist!", inc_hints.string());
    }

    lib_path = fs::canonical(vm["path"].as<std::string>());
    if (!fs::exists(lib_path) || !fs::is_directory(lib_path))
    {
        LOGWARN("library path {{}} does not exsit!", lib_path.string());
    }

    WriteCMakeFindModule();
    LOGINFO("successfully added library: {}, inc-path:{}, lib-path:{}", name, inc_hints.string(),
        lib_path.string());
}

void WriteCMakeFindModule()
{
    if (!IsProjectRoot())
    {
        LOGERR("must be under the project root directory!");
    }

    if (!fs::exists("cmake_modules") || !fs::is_directory("cmake_modules"))
    {
        LOGERR("cmake_modules directory does not exist!");
    }
    // for example, a library name 'libboost_program_options.so'
    // the target name when add-library should be 'boost_program_options'
    // Pascalization turns 'boost_program_options' into 'BoostProgramOptions'
    std::string pascal_name = Pascalization(name);

    // the custom module file in absolute path, such as : /home/user/repo/FindMyLib.cmake
    fs::path module_path =
        fs::current_path() / "cmake_modules" / fmt::format("Find{}.cmake", pascal_name);
    if (fs::exists(module_path))
    {
        LOGWARN("{} exists, overwrite? (N/y)", module_path.string());
        if (!PromptUserConfirm())
        {
            LOGINFO("abort, please clean up your workspace and retry.");
            exit(1);
        }
    }

    std::ofstream module_file(module_path.string());
    if (!module_file)
    {
        LOGERR("{} open fail, abort!");
    }
    // AbcDefGhi -> ABCDEFGHI
    std::string upper_pascal = ToUpper(pascal_name);

    module_file << fmt::format(R"==(# custom Find{0}.cmake generated by CMaker

find_library({1}_LIBRARIES
    NAMES {5}
    PATHS {2})

find_path({1}_INCLUDE_DIR
  NAMES {3}
  PATHS {4})

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args({0}
  DEFAULT_MSG {1}_LIBRARIES {1}_INCLUDE_DIR)

mark_as_advanced(
  {1}_LIBRARIES
  {1}_INCLUDE_DIR)

if({0}_FOUND AND NOT (TARGET {0}::{0}))
  add_library({0}::{0} UNKNOWN IMPORTED)
  set_target_properties({0}::{0}
    PROPERTIES
      IMPORTED_LOCATION ${{{1}_LIBRARIES}}
      INTERFACE_INCLUDE_DIRECTORIES ${{{1}_INCLUDE_DIR}}
      IMPORTED_LINK_INTERFACE_LANGUAGES "CXX")
endif()
)==",
        pascal_name, upper_pascal, lib_path.string(), inc_names, inc_hints.string(), name);

    LOGINFO("module_file: {} created.", module_path.string());
}